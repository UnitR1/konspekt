# Ссылки
Ссылка — это тип переменной в языке C++, который работает как псевдоним другого объекта или значения.

Ссылка объявляется с использованием амперсанда (&) между типом данных и именем ссылки:
```c++
int value = 7; // обычная переменная
int &ref = value; // ссылка на переменную value
```
В этом контексте амперсанд не означает «оператор адреса», он означает «ссылка на».

## Ссылки в качестве псевдонимов

Ссылки обычно ведут себя идентично значениям, на которые они ссылаются. В этом смысле ссылка работает как псевдоним объекта, на который она ссылается, например:
```c++
#include <iostream>

int main()
{
	int value = 7; // обычная переменная
	int &ref = value; // ссылка на переменную value

	value = 8; // value теперь 8
	ref = 9; // value теперь 9

	std::cout << value << std::endl; // выведется 9
	++ref;
	std::cout << value << std::endl; // выведется 10

	return 0;
}
```
Результат выполнения программы:

9
10

В примере, приведенном выше, объекты ref и value обрабатываются как одно целое. Использование оператора адреса с ссылкой приведет к возврату адреса значения, на которое ссылается ссылка:
```c++
std::cout << &value; // выведется 0035FE58
std::cout << &ref; // выведется 0035FE58
```
## Инициализация ссылок

Ссылки должны быть инициализированы при создании:
```c++
int value = 7;
int &ref = value; // корректная ссылка: инициализирована переменной value

int &invalidRef; // некорректная ссылка: ссылка должна ссылаться на что-либо
```
В отличие от указателей, которые могут содержать нулевое значение, ссылки нулевыми быть не могут.
```c++
int a = 7;
int &ref1 = a; // ок

const int b = 8;
int &ref2 = b; // не ок

int &ref3 = 4; // не ок
```
Обратите внимание, во втором случае вы не можете инициализировать неконстантную ссылку константным объектом. В противном случае, вы бы могли изменить значение константного объекта через ссылку, что уже является нарушением понятия «константа».

После инициализации изменить объект, на который указывает ссылка — нельзя.

## Ссылки в качестве параметров в функциях
Ссылки чаще всего используются в качестве параметров в функциях. В этом контексте ссылка-параметр работает как псевдоним аргумента, а сам аргумент не копируется при передаче в параметр. Это в свою очередь улучшает производительность, если аргумент слишком большой или затратный для копирования.

Ссылки работают аналогично. Поскольку ссылка-параметр — это псевдоним аргумента, то функция, использующая ссылку-параметр, может изменять аргумент, переданный ей, также напрямую:
```c++
#include <iostream>

// ref - это ссылка на переданный аргумент, а не копия аргумента
void changeN(int &ref)
{
	ref = 8;
}

int main()
{
	int x = 7;

	std::cout << x << '\n';

	changeN(x); // обратите внимание, этот аргумент не обязательно должен быть ссылкой

	std::cout << x << '\n';
	return 0;
}
```
Результат выполнения программы:

7
8

Когда аргумент x передается в функцию, то параметр функции ref становится ссылкой на аргумент x. Это позволяет функции изменять значение x непосредственно через ref.

## Ссылки как более легкий способ доступа к данным

Второе (гораздо менее используемое) применение ссылок заключается в более легком способе доступа к вложенным данным. Рассмотрим следующую структуру:
```c++
struct Something
{
    int value1;
    float value2;
};

struct Other
{
    Something something;
    int otherValue;
};

Other other;
```
Предположим, что нам нужно работать с полем value1 структуры Something переменной other структуры Other (звучит сложно, но такое также встречается на практике). Обычно, доступ к этому полю осуществлялся бы через other.something.value1. А что, если нам нужно неоднократно получать доступ к этому члену? В этом случае код становится громоздким и беспорядочным. Ссылки же предоставляют более легкий способ доступа к данным:
```c++
int &ref = other.something.value1;
// ref теперь может использоваться вместо other.something.value1
```
Таким образом, следующие два стейтмента идентичны:
```c++
other.something.value1 = 7;
ref = 7;
```
Ссылки позволяют сделать ваш код более чистым и понятным.

## Ссылки vs. Указатели
Ссылка — это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает («под капотом» ссылки реализованы с помощью указателей). Таким образом, в следующем коде:
```c++
int value = 7;
int *const ptr = &value;
int &ref = value;
```
*ptr и ref обрабатываются одинаково. Т.е. это одно и то же:
```c++
*ptr = 7;
ref = 7;
```
Поскольку ссылки должны быть инициализированы корректными объектами (они не могут быть нулевыми) и не могут быть изменены позже, то они, как правило, безопаснее указателей (так как риск разыменования нулевого указателя отпадает). Однако они немного ограничены в функциональности по сравнению с указателями.

Если определенное задание может быть решено с помощью как ссылок, так и указателей, то лучше использовать ссылки. Указатели следует использовать только в тех ситуациях, когда ссылки являются недостаточно эффективными (например, при динамическом выделении памяти).

Источник: https://ravesli.com/urok-88-ssylki/
