## Введение в лямбда-выражения

Лямбда-выражение (или просто «лямбда») в программировании позволяет определить анонимную функцию внутри другой функции. Возможность сделать функцию вложенной является очень важным преимуществом, так как позволяет избегать как захламления пространства имен лишними объектами, так и определить функцию как можно ближе к месту её первого использования.

Синтаксис лямбда-выражений является одним из самых странных в языке C++, и вам может потребоваться некоторое время, чтобы к нему привыкнуть.

Лямбда-выражения имеют следующий синтаксис:

[ captureClause ] ( параметры ) -> возвращаемыйТип
{
стейтменты;
}

Поля captureClause и параметры могут быть пустыми, если они не требуются программисту.

Поле возвращаемый тип является опциональным, и, если его нет, то будет использоваться вывод типа с помощью ключевого слова auto. Хотя мы ранее уже отмечали, что следует избегать использования вывода типа для возвращаемых значений функций, в данном контексте подобное использование допускается (поскольку обычно такие функции являются тривиальными).

Также обратите внимание, что лямбда-выражения не имеют имен, поэтому нам и не нужно будет их предоставлять. Из этого факта следует, что тривиальное определение лямбды может иметь следующий вид:
```c++
#include <iostream>

int main()
{
  []() {}; // определяем лямбда-выражение без captureClause, параметров и возвращаемого типа

  return 0;
}
```
Давайте перепишем предыдущий пример, но уже с использованием лямбда-выражений:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main()
{
  std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };

  // Определяем функцию непосредственно в том месте, где собираемся её использовать
  auto found{ std::find_if(arr.begin(), arr.end(),
                           [](std::string_view str) // вот наша лямбда, без поля captureClause
                           {
                             return (str.find("nut") != std::string_view::npos);
                           }) };

  if (found == arr.end())
  {
    std::cout << "No nuts\n";
  }
  else
  {
    std::cout << "Found " << *found << '\n';
  }

  return 0;
}
```
При этом всё работает точно так же, как и в случае с указателем на функцию. Результат выполнения программы аналогичен:

Found walnut

Обратите внимание, насколько наша лямбда похожа на функцию containsNut(). Они обе имеют одинаковые параметры и тела функций. Отметим, что у лямбды отсутствует поле captureClause (детально о captureClause мы говорим на уроке о лямбда-захватах), т.к. оно не нужно. Также для краткости мы пропустили синтаксис типа возвращаемого значения trailing, но из-за того, что operator!= возвращает значение типа bool, наша лямбда также будет возвращать логическое значение.

## Тип лямбда-выражений
В примере, приведенном выше, мы определили лямбду прямо в том месте, где она была нам нужна. Такое использование лямбда-выражения иногда еще называют функциональным литералом.

Однако написание лямбды в той же строке, где она используется, иногда может затруднить чтение кода. Подобно тому, как мы можем инициализировать переменную с помощью литерала (или указателя на функцию) для использования в дальнейшем, так же мы можем инициализировать и лямбда-переменную с помощью лямбда-определения для её дальнейшего использования. Именованная лямбда вместе с удачным именем функции может облегчить чтение кода.

Например, в следующем фрагменте кода мы используем функцию std::all_of() для того, чтобы проверить, являются ли все элементы массива чётными:
```c++
// Плохо: Мы должны прочитать лямбду, чтобы понять, что происходит
return std::all_of(array.begin(), array.end(), [](int i){ return ((i % 2) == 0); });
```
Мы можем улучшить читабельность кода следующим образом:
```c++
// Хорошо: Мы можем хранить лямбду в именованной переменной и передавать её в функцию в качестве параметра
auto isEven{
  [](int i)
  {
    return ((i % 2) == 0);
  }
};

return std::all_of(array.begin(), array.end(), isEven);
```
Обратите внимание, как просто читается последняя строка кода: «… возвращаем все элементы массива, которые являются чётными …».

Но какого типа является лямбда в isEven?

Оказывается, у лямбд нет типа, который мы могли бы явно использовать. Когда мы пишем лямбду, компилятор генерирует уникальный тип лямбды, который нам не виден.

Для продвинутых читателей: На самом деле, лямбды не являются функциями (что и помогает им избегать ограничений языка C++, которые накладываются на использование вложенных функций). Лямбды являются особым типом объектов, который называется функтором. Функторы — это объекты, содержащие перегруженный operator(), который и делает их вызываемыми подобно обычным функциям.

Хотя мы не знаем тип лямбды, есть несколько способов её хранения для использования после определения. Если лямбда ничего не захватывает, то мы можем использовать обычный указатель на функцию. Как только лямбда что-либо захватывает, указатель на функцию больше не будет работать. Однако std::function может использоваться для лямбд, даже если они что-то захватывают:
```c++
#include <functional>

int main()
{
  // Обычный указатель на функцию. Лямбда не может ничего захватить
  double (*addNumbers1)(double, double){
    [](double a, double b) {
      return (a + b);
    }
  };

  addNumbers1(1, 2);

  // Используем std::function. Лямбда может захватывать переменные
  std::function addNumbers2{ // примечание: Если у вас не поддерживается C++17, используйте std::function<double(double, double)>
    [](double a, double b) {
      return (a + b);
    }
  };

  addNumbers2(3, 4);

  // Используем auto. Храним лямбду с её реальным типом
  auto addNumbers3{
    [](double a, double b) {
      return (a + b);
    }
  };

  addNumbers3(5, 6);

  return 0;
}
```
С помощью auto мы можем использовать фактический тип лямбды. При этом мы можем получить преимущество в виде отсутствия накладных расходов в сравнении с использованием std::function.

К сожалению, мы не всегда можем использовать auto. В тех случаях, когда фактический тип лямбды неизвестен (например, из-за того, что мы передаем лямбду в функцию в качестве параметра, и вызывающий объект сам определяет какого типа лямбда будет передана), мы не можем использовать auto. В таких случаях следует использовать std::function:
```c++
#include <functional>
#include <iostream>

// Мы не знаем, чем будет fn. std::function работает с обычными функциями и лямбдами
void repeat(int repetitions, const std::function<void(int)>& fn)
{
  for (int i{ 0 }; i < repetitions; ++i)
  {
    fn(i);
  }
}

int main()
{
  repeat(3, [](int i) {
    std::cout << i << '\n';
  });

  return 0;
}
```
Результат выполнения программы:

0
1
2

Правило: Используйте auto при инициализации переменных с помощью лямбд и std::function, если вы не можете инициализировать переменную с помощью лямбд.

## Общие/Обобщённые лямбды

По большей части лямбда-параметры работают так же, как и обычные параметры функций.

Одним примечательным исключением является то, что, начиная с C++14, нам разрешено использовать auto с параметрами функций.

Примечание: В C++20 обычные функции также могут использовать auto с параметрами.

Если у лямбды есть один или несколько параметров auto, то компилятор определит необходимые типы параметров из вызовов лямбд-выражений.

Поскольку лямбды с одним или несколькими параметрами типа auto потенциально могут работать с большим количество типов данных, то они называются общими (или «обобщёнными», от англ. «generic lambdas») лямбдами.

Рассмотрим использование общей лямбды на практике:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main()
{
  std::array months{ // если у вас не поддерживается C++17, то используйте std::array<std::string_view, 12>
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  };

  // Поиск двух последовательных месяцев, которые начинаются с одинаковой буквы
  auto sameLetter{ std::adjacent_find(months.begin(), months.end(),
                                      [](const auto& a, const auto& b) {
                                        return (a[0] == b[0]);
                                      }) };

  // Убеждаемся, что эти два месяца были найдены
  if (sameLetter != months.end())
  {
    std::cout << *sameLetter << " and " << *std::next(sameLetter)
              << " start with the same letter\n";
  }

  return 0;
}
```
Результат выполнения программы:

June and July start with the same letter

В примере, приведенном выше, мы использовали auto-параметры для захвата наших строк с использованием константной ссылки. Т.к. все строковые типы предоставляют доступ к своим отдельным символам через оператор [], то нам не нужно волноваться о том, передает ли пользователь в качестве параметра std::string, строку C-style или что-то другое. Это позволяет нам написать лямбду, которая могла бы принять любой из этих объектов, то есть, если позже мы изменим тип months, — нам не придется переписывать лямбду.

Однако auto не всегда является лучшим выбором. Рассмотрим следующую программу:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main()
{
  std::array months{ // если у вас не поддерживается C++17, то используйте std::array<const char*, 12>
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  };

  // Подсчитываем количество месяцев с названиями в 5 букв
  auto fiveLetterMonths{ std::count_if(months.begin(), months.end(),
                                       [](std::string_view str) {
                                         return (str.length() == 5);
                                       }) };

  std::cout << "There are " << fiveLetterMonths << " months with 5 letters\n";

  return 0;
}
```
Результат выполнения программы:

There are 2 months with 5 letters

В этом примере использование auto выводит тип const char*. Мы знаем, что со строками C-style трудно работать (кроме использования оператора []). Поэтому в данном случае для нас предпочтительнее явно определить тип параметра, как std::string_view, который позволит нам работать с базовыми типами данных намного проще (например, мы можем запросить у представления значение длины строки, даже если пользователь передал в качестве аргумента массив C-style).

## Общие лямбды и статические переменные
Следует иметь в виду, что для каждого отдельного типа, выводимого с помощью auto, будет сгенерирована уникальная лямбда. В следующем примере показано, как общая лямбда разделяется на две отдельные:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main()
{
  // Выводим значение и подсчитываем, сколько раз будет вызван print
  auto print{
    [](auto value) {
      static int callCount{ 0 };
      std::cout << callCount++ << ": " << value << '\n';
    }
  };

  print("hello"); // 0: hello
  print("world"); // 1: world

  print(1); // 0: 1
  print(2); // 1: 2

  print("ding dong"); // 2: ding dong

  return 0;
}
```
Результат выполнения программы:

0: hello
1: world
0: 1
1: 2
2: ding dong

В примере, приведенном выше, мы определяем лямбду и затем вызываем её с двумя различными параметрами (строковым литералом и целочисленным типом). При этом генерируются две различные версии лямбды (одна с параметром строкового литерала, а другая — с параметром в виде целочисленного типа).

В большинстве случаев это не существенно. Однако, обратите внимание, что если в общей лямбде используются статические переменные, то эти переменные не являются общими для генерируемых лямбд.

Мы можем видеть это в вышеприведенном примере, где каждый тип (строковые литералы и целые числа) имеет свой собственный уникальный счет! Хотя мы написали лямбду один раз, были сгенерированы две лямбды, и у каждой есть своя версия callCount.

Если бы мы хотели, чтобы callCount был общим для лямбд, то нам пришлось бы объявить его вне лямбды и захватить его по ссылке, чтобы он мог быть изменен лямбдой.

## Вывод возвращаемого типа и возвращаемые типы trailing

Если использовался вывод возвращаемого типа, то возвращаемый тип лямбды выводится из стейтментов return внутри лямбды. Если использовался вывод возвращаемого типа, то все возвращаемые стейтменты внутри лямбды должны возвращать значения одного и того же типа (иначе компилятор не будет знать, какой из них ему следует использовать). Например:
```c++
#include <iostream>

int main()
{
  auto divide{ [](int x, int y, bool bInteger) { // примечание: Не указан тип возвращаемого значения
    if (bInteger)
      return x / y;
    else
      return static_cast<double>(x) / y; // ОШИБКА: Тип возвращаемого значения не совпадает с предыдущим возвращаемым типом
  } };

  std::cout << divide(3, 2, true) << '\n';
  std::cout << divide(3, 2, false) << '\n';

  return 0;
}
```
Это приведет к ошибке компиляции, так как тип возвращаемого значения первого стейтмента return (int) не совпадает с типом возвращаемого значения второго стейтмента return (double).

В случае, когда у нас используются разные возвращаемые типы, у нас есть два варианта:

   выполнить явные преобразования в один тип;

   явно указать тип возвращаемого значения для лямбды и позволить компилятору выполнить неявные преобразования.

Второй вариант обычно является более предпочтительным:
```c++
#include <iostream>

int main()
{
  // Примечание: Явно указываем тип double для возвращаемого значения
  auto divide{ [](int x, int y, bool bInteger) -> double {
    if (bInteger)
      return x / y; // выполнится неявное преобразование в тип double
    else
      return static_cast<double>(x) / y;
  } };

  std::cout << divide(3, 2, true) << '\n';
  std::cout << divide(3, 2, false) << '\n';

  return 0;
}
```
Таким образом, если вы когда-либо решите изменить тип возвращаемого значения, вам (как правило) нужно будет изменить только тип возвращаемого значения лямбды и ничего внутри основной части.

## Функциональные объекты Стандартной библиотеки С++
Для основных операций (например, сложения, вычитания или сравнения) вам не нужно писать свои собственные лямбды, потому что Стандартная библиотека С++ поставляется со многими базовыми вызываемыми объектами, которые вы можете использовать. Эти объекты определены в заголовочном файле functional. Например:
```c++
#include <algorithm>
#include <array>
#include <iostream>

bool greater(int a, int b)
{
  // Размещаем a перед b, если a больше b
  return (a > b);
}

int main()
{
  std::array arr{ 13, 90, 99, 5, 40, 80 };

  // Передаем greater в качестве параметра в std::sort()
  std::sort(arr.begin(), arr.end(), greater);

  for (int i : arr)
  {
    std::cout << i << ' ';
  }

  std::cout << '\n';

  return 0;
}
```
Результат выполнения программы:

99 90 80 40 13 5

Вместо преобразования функции greater() в лямбду, мы можем использовать std::greater:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <functional> // для std::greater

int main()
{
  std::array arr{ 13, 90, 99, 5, 40, 80 };

  // Передаем std::greater в качестве параметра в std::sort()
  std::sort(arr.begin(), arr.end(), std::greater{}); // примечание: Требуются фигурные скобки для создания объекта

  for (int i : arr)
  {
    std::cout << i << ' ';
  }

  std::cout << '\n';

  return 0;
}
```
Результат выполнения программы:

99 90 80 40 13 5

Источник: https://ravesli.com/lyambda-vyrazheniya-anonimnye-funktsii-v-s/
